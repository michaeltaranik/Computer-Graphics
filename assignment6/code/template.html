<html>
<head>
    <meta charset="UTF-8">
    <script src="gl-matrix-min.js"></script>
    <script src="geometry.js"></script>
    <script type="text/javascript">

        var vertexShaderCode =
            `#version 300 es
            in vec3 a_position;
            in vec3 a_color;
            in vec3 a_normal;

            out vec3 v_color;
            out vec3 v_normal;
            out vec3 v_position; // world space position

            uniform mat4 u_model;
            uniform mat4 u_view;
            uniform mat4 u_projection;

            void main(){
                v_color = a_color;
                
                // calculate world space position and normal
                v_position = vec3(u_model * vec4(a_position, 1.0));
                
                v_normal = mat3(u_model) * a_normal; 
                
                gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
            }`;

        var fragmentShaderCode =
            `#version 300 es
            precision mediump float;

            in vec3 v_color;
            in vec3 v_normal;
            in vec3 v_position;

            out vec4 out_color;

            uniform vec3 u_lightDirection; // direction from light to origin
            uniform vec3 u_viewPosition;   // camera world position

            void main(){
                // properties
                vec3 normal = normalize(v_normal);
                vec3 lightDir = normalize(-u_lightDirection); // invert to point to light
                vec3 viewDir = normalize(u_viewPosition - v_position);

                // 1. ambient
                float ambientStrength = 0.05;
                vec3 ambient = ambientStrength * v_color;

                // 2. diffuse
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 diffuse = diff * v_color;

                // 3. specular (phong)
                float specularStrength = 0.5;
                vec3 reflectDir = reflect(-lightDir, normal);
                // shininess
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);
                vec3 specular = specularStrength * spec * vec3(1.0, 1.0, 1.0); // white highlight

                // --- TONE MAPPING START ---
                vec3 result = ambient + diffuse + specular;
                float exposure = 1.2;
                // This maps values > 1.0 down to the [0, 1] range smoothly
                result *= exposure;
                result = result / (result + vec3(1.0));
                result = pow(result, vec3(1.0 / 2.2));
                out_color = vec4(result, 1.0);
            }`;

        var gl;
        var shaderProgram;
        var triangle_vao, plane_vao, cube_vao, sphere_vao;

        function initWebGL() {
            var canvas = document.getElementById("webgl-canvas");
            gl = canvas.getContext("webgl2");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;

            if (gl) {
                console.log("WebGL successfully initialized.");
            } else {
                console.log("Failed to initialize WebGL.")
            }
        }

        function compileShader(shader, source, type, name = "") {
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
                console.log(name + " shader compiled successfully.");
            } else {
                console.log(name + " shader error:");
                console.log(gl.getShaderInfoLog(shader));
            }
        }

        function linkProgram(program, vertShader, fragShader) {
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.log("Shaders linked successfully.");
            } else {
                console.log("Could not link shaders.");
                console.log(gl.getProgramInfoLog(program));
            }
        }

        function createGLSLPrograms() {
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            compileShader(vertexShader, vertexShaderCode, gl.VERTEX_SHADER, "Vertex");

            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            compileShader(fragmentShader, fragmentShaderCode, gl.FRAGMENT_SHADER, "Fragment");

            shaderProgram = gl.createProgram();
            linkProgram(shaderProgram, vertexShader, fragmentShader);
        }

        function createVAO(vao, vertices, normals, colors) {
            gl.bindVertexArray(vao);

            // position buffer
            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            var posLoc = gl.getAttribLocation(shaderProgram, "a_position");
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

            // color buffer
            var colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            var colorLoc = gl.getAttribLocation(shaderProgram, "a_color");
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

            // normal buffer
            if (normals && normals.length > 0) {
                var normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
                var normalLoc = gl.getAttribLocation(shaderProgram, "a_normal");
                if (normalLoc !== -1) {
                    gl.enableVertexAttribArray(normalLoc);
                    gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);
                }
            }

            gl.bindVertexArray(null);
        }

        function initBuffers() {
            sphere_normals = [...sphere_vertices];

            // create VAOs for all objects
            plane_vao = gl.createVertexArray();
            createVAO(plane_vao, plane_vertices, plane_normals, plane_colors);

            cube_vao = gl.createVertexArray();
            createVAO(cube_vao, cube_vertices, cube_normals, cube_colors);

            sphere_vao = gl.createVertexArray();
            createVAO(sphere_vao, sphere_vertices, sphere_normals, sphere_colors);

            triangle_vao = gl.createVertexArray();
            gl.bindVertexArray(triangle_vao);

            var triangleVertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.5, -0.5, 0.0, 0.0, 0.5, 0.0, -0.5, -0.5, 0.0]), gl.STATIC_DRAW);
            var posLoc = gl.getAttribLocation(shaderProgram, "a_position");
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

            var triangleColorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangleColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0]), gl.STATIC_DRAW);
            var colorLoc = gl.getAttribLocation(shaderProgram, "a_color");
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(null);
        }

        function draw() {
            let camera_azimuthal_angle = document.getElementById("camera_azimuthal_angle").value / 360 * 2 * Math.PI;
            let camera_polar_angle = document.getElementById("camera_polar_angle").value / 360 * 2 * Math.PI;
            let camera_distance = parseFloat(document.getElementById("camera_distance").value);
            let camera_fov = document.getElementById("camera_fov").value / 360 * 2 * Math.PI;
            let light_azimuthal_angle = document.getElementById("light_azimuthal_angle").value / 360 * 2 * Math.PI;
            let light_polar_angle = document.getElementById("light_polar_angle").value / 360 * 2 * Math.PI;

            let camera_x = camera_distance * Math.sin(camera_polar_angle) * Math.cos(camera_azimuthal_angle);
            let camera_y = camera_distance * Math.cos(camera_polar_angle);
            let camera_z = camera_distance * Math.sin(camera_polar_angle) * Math.sin(camera_azimuthal_angle);
            let camera_position = vec3.fromValues(camera_x, camera_y, camera_z);

            let light_x = Math.sin(light_polar_angle) * Math.cos(light_azimuthal_angle);
            let light_y = Math.cos(light_polar_angle);
            let light_z = Math.sin(light_polar_angle) * Math.sin(light_azimuthal_angle);
            let lightDirection = vec3.fromValues(-light_x, -light_y, -light_z);

            var projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, camera_fov, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);

            var viewMatrix = mat4.create();
            mat4.lookAt(viewMatrix, camera_position, vec3.fromValues(0,0,0), vec3.fromValues(0,1,0));

            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            
            gl.clearColor(0.2, 0.2, 0.2, 1.0); 
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(shaderProgram);

            // uniforms
            var u_model = gl.getUniformLocation(shaderProgram, "u_model");
            var u_view = gl.getUniformLocation(shaderProgram, "u_view");
            var u_projection = gl.getUniformLocation(shaderProgram, "u_projection");
            var u_lightDirection = gl.getUniformLocation(shaderProgram, "u_lightDirection");
            var u_viewPosition = gl.getUniformLocation(shaderProgram, "u_viewPosition");

            gl.uniformMatrix4fv(u_view, false, viewMatrix);
            gl.uniformMatrix4fv(u_projection, false, projectionMatrix);
            gl.uniform3fv(u_lightDirection, lightDirection);
            gl.uniform3fv(u_viewPosition, camera_position);

            var modelMatrix = mat4.create();
            mat4.scale(modelMatrix, modelMatrix, [10.0, 1.0, 10.0]);
            gl.uniformMatrix4fv(u_model, false, modelMatrix);
            gl.bindVertexArray(plane_vao);
            gl.drawArrays(gl.TRIANGLES, 0, plane_vertices.length / 3);

            // right cube
            modelMatrix = mat4.create();
            mat4.translate(modelMatrix, modelMatrix, [-1.5, 0.5, 0.0]); 
            // mat4.scale(modelMatrix, modelMatrix, [0.8, 0.8, 0.8]); 
            gl.uniformMatrix4fv(u_model, false, modelMatrix);
            gl.bindVertexArray(cube_vao);
            gl.drawArrays(gl.TRIANGLES, 0, cube_vertices.length / 3);

            // left cube
            modelMatrix = mat4.create();
            mat4.translate(modelMatrix, modelMatrix, [1.5, 0.5, 0.0]);
            // rotate cube
            mat4.rotateY(modelMatrix, modelMatrix, Math.PI / 4);
            // mat4.scale(modelMatrix, modelMatrix, [0.8, 0.8, 0.8]);
            gl.uniformMatrix4fv(u_model, false, modelMatrix);
            gl.drawArrays(gl.TRIANGLES, 0, cube_vertices.length / 3);

            // sphere
            modelMatrix = mat4.create();
            mat4.translate(modelMatrix, modelMatrix, [0.0, 0.7, 0.0]);
            mat4.scale(modelMatrix, modelMatrix, [1.0, 1, 1]);
            gl.uniformMatrix4fv(u_model, false, modelMatrix);
            gl.bindVertexArray(sphere_vao);
            gl.drawArrays(gl.TRIANGLES, 0, sphere_vertices.length / 3);

            window.requestAnimationFrame(draw);
        }

        function start() {
            initWebGL();
            createGLSLPrograms();
            initBuffers();
            draw();
        }

    </script>
</head>
<body onload="start();">
    <canvas id="webgl-canvas" width="768" height="768"></canvas>
    <div style="float: right">
        <h4>Camera:</h4>
        <div class="slidecontainer">
            Azimuthal angle:<br><input type="range" min="-270" max="90" value="-45" id="camera_azimuthal_angle">
        </div>
        <div class="slidecontainer">
            Polar angle:<br><input type="range" min="1" max="179" value="60" id="camera_polar_angle">
        </div>
        <div class="slidecontainer">
            Distance:<br><input type="range" min="5" max="70" value="15" id="camera_distance">
        </div>
        <div class="slidecontainer">
            Field of view:<br><input type="range" min="10" max="150" value="45" id="camera_fov">
        </div>

        <h4>Light:</h4>
        <div class="slidecontainer">
            Azimuthal angle:<br><input type="range" min="-270" max="90" value="-70" id="light_azimuthal_angle">
        </div>
        <div class="slidecontainer">
            Polar angle:<br><input type="range" min="1" max="90" value="60" id="light_polar_angle">
        </div>
    </div>
</body>

</html>